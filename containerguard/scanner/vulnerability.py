"""
Vulnerability scanner module for detecting software vulnerabilities in containers.
"""
import asyncio
import json
import logging
import os
import subprocess
import tempfile
import time
from typing import Any, Dict, List, Optional, Tuple

import docker

from containerguard.scanner.base import BaseScanner, Finding, ScanResult
from containerguard.utils import docker as docker_utils
from containerguard.utils import trivy as trivy_utils

logger = logging.getLogger(__name__)


class VulnerabilityScanner(BaseScanner):
    """
    Scanner for detecting vulnerabilities in container images.

    This scanner uses Trivy as the primary vulnerability scanner and
    can optionally integrate with other scanners for comprehensive coverage.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the vulnerability scanner.

        Args:
            config: Scanner configuration
        """
        super().__init__("vulnerability", config)
        self.client = docker.from_env()

        # Configure scanner priority and integrations
        self.use_trivy = self.config.get("use_trivy", True)
        self.use_grype = self.config.get("use_grype", False)
        self.use_clair = self.config.get("use_clair", False)

        # Configure vulnerability filtering
        self.severity_threshold = self.config.get("severity_threshold", "low")
        self.ignored_vulnerabilities = self.config.get("ignored_vulnerabilities", [])
        self.max_findings = self.config.get("max_findings", 1000)

        # Configure scanner behavior
        self.offline_mode = self.config.get("offline_mode", False)
        self.update_databases = self.config.get("update_databases", True)

        logger.info(f"Initialized vulnerability scanner with severity threshold: {self.severity_threshold}")

    async def scan(self, target: str, options: Optional[Dict[str, Any]] = None) -> ScanResult:
        """
        Scan a container image for vulnerabilities.

        Args:
            target: Container image name or ID
            options: Additional scan options

        Returns:
            ScanResult containing vulnerability findings
        """
        options = options or {}
        logger.info(f"Scanning {target} for vulnerabilities")
        start_time = time.time()

        # Ensure target is a valid Docker image
        if not docker_utils.is_valid_image(target):
            raise ValueError(f"Invalid Docker image: {target}")

        results = []

        # Use multiple scanners if configured
        if self.use_trivy:
            try:
                trivy_result = await self._scan_with_trivy(target, options)
                results.append(trivy_result)
            except Exception as e:
                logger.error(f"Trivy scan failed: {e}")

        # Add more scanners as needed
        if self.use_grype:
            # Placeholder for Grype scanner integration
            pass

        if self.use_clair:
            # Placeholder for Clair scanner integration
            pass

        # Merge results if we have multiple scanners
        if len(results) > 1:
            scan_result = self.merge_results(results)
        elif len(results) == 1:
            scan_result = results[0]
        else:
            # Create empty result if all scanners failed
            scan_result = ScanResult(
                scanner_name=self.name,
                target=target,
                findings=[],
                summary={"error": "All configured scanners failed"},
                scan_time=time.time() - start_time,
                timestamp=time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                metadata={"error": True},
            )

        # Apply filtering based on configuration
        filtered_findings = self._filter_findings(scan_result.findings)
        scan_result.findings = filtered_findings[:self.max_findings]

        # Update summary with filtered counts
        scan_result.summary.update({
            "critical_count": scan_result.critical_count,
            "high_count": scan_result.high_count,
            "medium_count": scan_result.medium_count,
            "low_count": scan_result.low_count,
            "info_count": scan_result.info_count,
            "total_count": scan_result.total_count,
        })

        logger.info(f"Vulnerability scan completed with {scan_result.total_count} findings")
        return scan_result

    async def scan_file(self, file_path: str, options: Optional[Dict[str, Any]] = None) -> ScanResult:
        """
        Scan a Dockerfile or similar file for vulnerabilities.

        Args:
            file_path: Path to the file to scan
            options: Additional scan options

        Returns:
            ScanResult containing vulnerability findings
        """
        options = options or {}
        logger.info(f"Scanning file {file_path} for vulnerabilities")
        start_time = time.time()

        if not os.path.isfile(file_path):
            raise FileNotFoundError(f"File not found: {file_path}")

        # For Dockerfiles, build a temporary image and scan it
        if os.path.basename(file_path).lower() == "dockerfile":
            with tempfile.TemporaryDirectory() as tmp_dir:
                # Copy Dockerfile to temp directory
                subprocess.run(["cp", file_path, os.path.join(tmp_dir, "Dockerfile")], check=True)

                # Build temporary image
                image_tag = f"containerguard-temp-{int(time.time())}"
                build_cmd = ["docker", "build", "-t", image_tag, tmp_dir]
                subprocess.run(build_cmd, check=True)

                try:
                    # Scan the temporary image
                    result = await self.scan(image_tag, options)

                    # Update metadata to reflect this was a Dockerfile scan
                    result.metadata["source_type"] = "dockerfile"
                    result.metadata["source_path"] = file_path

                    return result
                finally:
                    # Remove the temporary image
                    subprocess.run(["docker", "rmi", image_tag], check=True)
        else:
            # For other file types, use file scanners if available
            raise NotImplementedError(f"File scanning for {os.path.basename(file_path)} not implemented yet")

    async def _scan_with_trivy(self, target: str, options: Dict[str, Any]) -> ScanResult:
        """
        Scan a container image using Trivy.

        Args:
            target: Container image name or ID
            options: Additional scan options

        Returns:
            ScanResult containing Trivy findings
        """
        logger.info(f"Scanning {target} with Trivy")

        # Set Trivy options
        trivy_options = {
            "severity": options.get("severity", self.severity_threshold),
            "output_format": "json",
            "offline_mode": options.get("offline_mode", self.offline_mode),
            "update_db": options.get("update_db", self.update_databases),
        }

        # Run Trivy scan
        trivy_output = await trivy_utils.scan_image(target, trivy_options)

        # Parse Trivy JSON output
        trivy_json = json.loads(trivy_output)

        # Convert Trivy findings to our format
        findings = []

        # Process Trivy results
        for result in trivy_json.get("Results", []):
            for vuln in result.get("Vulnerabilities", []):
                # Skip ignored vulnerabilities
                if vuln.get("VulnerabilityID") in self.ignored_vulnerabilities:
                    continue

                # Create a finding for each vulnerability
                finding = Finding(
                    id=vuln.get("VulnerabilityID"),
                    title=vuln.get("Title") or f"Vulnerability in {vuln.get('PkgName')}",
                    description=vuln.get("Description") or "No description provided",
                    severity=self.normalize_severity(vuln.get("Severity", "unknown")),
                    category="vulnerability",
                    resource=f"{vuln.get('PkgName')}:{vuln.get('InstalledVersion')}",
                    location=result.get("Target", "unknown"),
                    recommendation=vuln.get(
                        "FixedVersion") and f"Upgrade to {vuln.get('PkgName')}:{vuln.get('FixedVersion')}" or "No fix available",
                    references=vuln.get("References") or [],
                    metadata={
                        "package_name": vuln.get("PkgName"),
                        "installed_version": vuln.get("InstalledVersion"),
                        "fixed_version": vuln.get("FixedVersion"),
                        "cve": vuln.get("VulnerabilityID"),
                        "cvss": vuln.get("CVSS"),
                        "cwe": vuln.get("CweIDs"),
                    },
                )
                findings.append(finding)

        # Create scan result
        return ScanResult(
            scanner_name="trivy",
            target=target,
            findings=findings,
            summary={
                "vulnerabilities_found": len(findings),
                "scan_target": target,
                "tool": "trivy",
                "tool_version": trivy_json.get("Version", "unknown"),
            },
            scan_time=time.time() - time.time(),  # Placeholder for actual scan time
            timestamp=time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            metadata=trivy_json.get("Metadata", {}),
        )

    def _filter_findings(self, findings: List[Finding]) -> List[Finding]:
        """
        Filter findings based on configuration.

        Args:
            findings: List of findings to filter

        Returns:
            Filtered list of findings
        """
        # Filter by severity threshold
        severity_levels = {
            "critical": 4,
            "high": 3,
            "medium": 2,
            "low": 1,
            "info": 0,
        }
        threshold = severity_levels.get(self.severity_threshold.lower(), 0)
        filtered = [f for f in findings if severity_levels.get(f.severity.lower(), 0) >= threshold]

        # Filter ignored vulnerabilities
        filtered = [f for f in filtered if f.id not in self.ignored_vulnerabilities]

        return filtered